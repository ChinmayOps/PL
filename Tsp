##GREEDY
import numpy as np

def calculate_distance(city1, city2):
    return np.linalg.norm(np.array(city1) - np.array(city2))

def greedy_tsp(cities):
    n = len(cities)
    unvisited = list(range(n))
    current_city = 0
    visited = [current_city]
    unvisited.remove(current_city)
    
    while unvisited:
        nearest_city = min(unvisited, key=lambda city: calculate_distance(cities[current_city], cities[city]))
        visited.append(nearest_city)
        current_city = nearest_city
        unvisited.remove(current_city)
    
    # Returning to the start city
    visited.append(visited[0])
    return visited

# Example usage:
cities = [(0, 0), (1, 2), (2, 4), (4, 2), (5, 1)]  # List of cities as (x, y) coordinates
path = greedy_tsp(cities)
print("Visited path:", path)

##ASTAR
import heapq
import numpy as np

# Function to calculate Euclidean distance between two cities
def calculate_distance(city1, city2):
    return np.linalg.norm(np.array(city1) - np.array(city2))

# Heuristic: Approximate cost of visiting remaining cities using MST (Minimum Spanning Tree)
def minimum_spanning_tree(cities, visited):
    unvisited = [i for i in range(len(cities)) if i not in visited]
    if not unvisited:
        return 0
    
    total_cost = 0
    current = unvisited[0]
    unvisited_set = set(unvisited)
    unvisited_set.remove(current)
    connected = {current}

    while unvisited_set:
        min_edge = float('inf')
        next_city = None
        for u in connected:
            for v in unvisited_set:
                dist = calculate_distance(cities[u], cities[v])
                if dist < min_edge:
                    min_edge = dist
                    next_city = v
        total_cost += min_edge
        connected.add(next_city)
        unvisited_set.remove(next_city)
    
    return total_cost

# A* search algorithm for TSP
def a_star_tsp(cities):
    n = len(cities)
    start_city = 0
    open_set = []
    heapq.heappush(open_set, (0, [start_city], set([start_city])))  # (total_cost, path, visited)

    while open_set:
        current_cost, current_path, visited = heapq.heappop(open_set)

        # If all cities are visited, return to start
        if len(visited) == n:
            final_cost = current_cost + calculate_distance(cities[current_path[-1]], cities[start_city])
            return current_path + [start_city], final_cost

        for next_city in range(n):
            if next_city not in visited:
                g_cost = current_cost + calculate_distance(cities[current_path[-1]], cities[next_city])
                new_path = current_path + [next_city]
                new_visited = visited | {next_city}
                h_cost = minimum_spanning_tree(cities, new_visited)
                total_cost = g_cost + h_cost
                heapq.heappush(open_set, (total_cost, new_path, new_visited))

# Example usage
cities = [(0, 0), (1, 2), (2, 4), (3, 1)]
path, total_cost = a_star_tsp(cities)
print("Visited path:", path)
print("Total cost:", total_cost)


#Method 2
'''import heapq
from itertools import permutations

# Distance matrix
graph = [
    [0, 2, 9, 10],
    [1, 0, 6, 4],
    [15, 7, 0, 8],
    [6, 3, 12, 0]
]

def tsp_astar(graph):
    n = len(graph)
    start = 0
    cities = list(range(n))
    cities.remove(start)

    # Priority queue: (total_cost, path)
    pq = []
    for perm in permutations(cities):
        path = [start] + list(perm) + [start]
        cost = sum(graph[path[i]][path[i+1]] for i in range(n))
        heapq.heappush(pq, (cost, path))

    best_cost, best_path = heapq.heappop(pq)
    print("A* TSP Path:", best_path)
    print("Total Cost:", best_cost)

tsp_astar(graph)'''
