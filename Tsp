##GREEDY
import numpy as np

def calculate_distance(city1, city2):
    return np.linalg.norm(np.array(city1) - np.array(city2))

def greedy_tsp(cities):
    n = len(cities)
    unvisited = list(range(n))
    current_city = 0
    visited = [current_city]
    unvisited.remove(current_city)
    
    while unvisited:
        nearest_city = min(unvisited, key=lambda city: calculate_distance(cities[current_city], cities[city]))
        visited.append(nearest_city)
        current_city = nearest_city
        unvisited.remove(current_city)
    
    # Returning to the start city
    visited.append(visited[0])
    return visited

cities = [(0, 0), (1, 2), (2, 4), (4, 2), (5, 1)]  # List of cities as (x, y) coordinates
path = greedy_tsp(cities)
print("Visited path:", path)


##ASTAR
import heapq
import numpy as np

# Calculate Euclidean distance between two cities
def calculate_distance(city1, city2):
    return np.linalg.norm(np.array(city1) - np.array(city2))

# Heuristic: Approx cost of visiting remaining cities using MST
def minimum_spanning_tree(cities, visited):
    unvisited = [i for i in range(len(cities)) if i not in visited]
    if not unvisited:
        return 0
    
    total_cost = 0
    current = unvisited[0]
    unvisited_set = set(unvisited)
    unvisited_set.remove(current)
    connected = {current}

    while unvisited_set:
        min_edge = float('inf')
        next_city = None
        for u in connected:
            for v in unvisited_set:
                dist = calculate_distance(cities[u], cities[v])
                if dist < min_edge:
                    min_edge = dist
                    next_city = v
        total_cost += min_edge
        connected.add(next_city)
        unvisited_set.remove(next_city)
    
    return total_cost

def a_star_tsp(cities):
    n = len(cities)
    start_city = 0
    open_set = []
    heapq.heappush(open_set, (0, [start_city], set([start_city])))  # (total_cost, path, visited)

    while open_set:
        current_cost, current_path, visited = heapq.heappop(open_set)

        # If all cities are visited, return to start
        if len(visited) == n:
            final_cost = current_cost + calculate_distance(cities[current_path[-1]], cities[start_city])
            return current_path + [start_city], final_cost

        for next_city in range(n):
            if next_city not in visited:
                g_cost = current_cost + calculate_distance(cities[current_path[-1]], cities[next_city])
                new_path = current_path + [next_city]
                new_visited = visited | {next_city}
                h_cost = minimum_spanning_tree(cities, new_visited)
                total_cost = g_cost + h_cost
                heapq.heappush(open_set, (total_cost, new_path, new_visited))

cities = [(0, 0), (1, 2), (2, 4), (3, 1)]
path, total_cost = a_star_tsp(cities)
print("Visited path:", path)
print("Total cost:", total_cost)


#Method 2
'''import heapq
from itertools import permutations

# Distance matrix
graph = [
    [0, 2, 9, 10],
    [1, 0, 6, 4],
    [15, 7, 0, 8],
    [6, 3, 12, 0]
]

def tsp_astar(graph):
    n = len(graph)
    start = 0
    cities = list(range(n))
    cities.remove(start)

    # Priority queue: (total_cost, path)
    pq = []
    for perm in permutations(cities):
        path = [start] + list(perm) + [start]
        cost = sum(graph[path[i]][path[i+1]] for i in range(n))
        heapq.heappush(pq, (cost, path))

    best_cost, best_path = heapq.heappop(pq)
    print("A* TSP Path:", best_path)
    print("Total Cost:", best_cost)

tsp_astar(graph)'''


//MST KRUSKAL'S
def minimum_spanning_tree(cities, visited):
    unvisited = [i for i in range(len(cities)) if i not in visited]
    if len(unvisited) <= 1:
        return 0

    # Create all edges between unvisited cities
    edges = []
    for i in range(len(unvisited)):
        for j in range(i + 1, len(unvisited)):
            u = unvisited[i]
            v = unvisited[j]
            dist = calculate_distance(cities[u], cities[v])
            edges.append((dist, u, v))

    # Sort edges by weight
    edges.sort()

    # Union-Find data structure for Kruskal's algorithm
    parent = {i: i for i in unvisited}

    def find(u):
        while parent[u] != u:
            parent[u] = parent[parent[u]]  # Path compression
            u = parent[u]
        return u

    def union(u, v):
        parent[find(u)] = find(v)

    total_cost = 0
    edge_count = 0
    for dist, u, v in edges:
        if find(u) != find(v):
            union(u, v)
            total_cost += dist
            edge_count += 1
            if edge_count == len(unvisited) - 1:
                break

    return total_cost
