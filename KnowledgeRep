def is_nearly_sorted(arr):
    count = 0
    for i in range(1, len(arr)):
        if arr[i] < arr[i - 1]:
            count += 1
    return count <= len(arr) * 0.1  # 10% disorder is allowed

def has_duplicates(arr):
    return len(arr) != len(set(arr))

# Sorting Algorithms

def insertion_sort(arr):
    print("Using Insertion Sort")
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

def bubble_sort(arr):
    print("Using Bubble Sort")
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

def selection_sort(arr):
    print("Using Selection Sort")
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

def quick_sort(arr):
    print("Using Quick Sort")
    if len(arr) <= 1:
        return arr
    pivot = arr[0]
    less = [x for x in arr[1:] if x <= pivot]
    greater = [x for x in arr[1:] if x > pivot]
    return quick_sort(less) + [pivot] + quick_sort(greater)

def merge_sort(arr):
    print("Using Merge Sort")
    if len(arr) > 1:
        mid = len(arr)//2
        L = merge_sort(arr[:mid])
        R = merge_sort(arr[mid:])
        return merge(L, R)
    else:
        return arr

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result += left[i:]
    result += right[j:]
    return result

# Rule-based reasoning engine
def select_sort_algorithm(arr):
    size = len(arr)

    if size < 10:
        if is_nearly_sorted(arr):
            return insertion_sort(arr.copy())
        else:
            return bubble_sort(arr.copy())

    if is_nearly_sorted(arr):
        return insertion_sort(arr.copy())

    if size > 1000:
        return merge_sort(arr.copy())

    if has_duplicates(arr) and size < 100:
        return selection_sort(arr.copy())

    return quick_sort(arr.copy())

# Example usage
if __name__ == "__main__":
    # Test different list scenarios here
    data = [7, 4, 9, 1, 3, 2, 5]  # Try different configurations
    sorted_data = select_sort_algorithm(data)
    print("Sorted Output:", sorted_data)

'''| Rule | Condition                            | Sorting Algorithm  |
| ---- | ------------------------------------ | ------------------ |
| R1   | List size < 10 and not nearly sorted | **Bubble Sort**    |
| R2   | List is nearly sorted                | **Insertion Sort** |
| R3   | List size > 1000                     | **Merge Sort**     |
| R4   | All elements are unique and random   | **Quick Sort**     |
| R5   | List contains duplicates and < 100   | **Selection Sort** |
| R6   | Default                              | **Quick Sort**     |
'''
